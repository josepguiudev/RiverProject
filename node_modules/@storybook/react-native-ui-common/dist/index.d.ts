import * as react from 'react';
import { ReactElement, FC, PropsWithChildren, ReactNode, SyntheticEvent, DependencyList, Dispatch, useState } from 'react';
import * as react_jsx_runtime from 'react/jsx-runtime';
import * as _storybook_react_native_theming from '@storybook/react-native-theming';
import { useTheme, Theme } from '@storybook/react-native-theming';
import * as react_native from 'react-native';
import { TouchableOpacityProps, PressableProps, ViewStyle, TextStyle, ImageStyle, StyleProp } from 'react-native';
import { StoryContext, Args } from 'storybook/internal/csf';
import { ReactRenderer } from '@storybook/react';
import { State, StoriesHash, API, IndexHash } from 'storybook/manager-api';
import { StatusesByStoryIdAndTypeId, StatusValue, API_IndexHash, API_PreparedStoryIndex, StoryIndexV2, StoryIndexV3, API_Provider, DocsOptions } from 'storybook/internal/types';

interface ButtonProps extends TouchableOpacityProps {
    asChild?: boolean;
    size?: 'small' | 'medium';
    padding?: 'small' | 'medium';
    variant?: 'outline' | 'solid' | 'ghost';
    disabled?: boolean;
    active?: boolean;
    animation?: 'none' | 'rotate360' | 'glow' | 'jiggle';
    text?: string;
    Icon?: (props: {
        color: string;
    }) => ReactElement;
}
declare const Button: react.ForwardRefExoticComponent<ButtonProps & react.RefAttributes<any>>;
declare const ButtonText: _storybook_react_native_theming.StyledComponent<react_native.TextProps & {
    theme?: useTheme;
    as?: React.ElementType;
} & {
    variant: ButtonProps["variant"];
    active: ButtonProps["active"];
}, {}, {
    ref?: react.Ref<react_native.Text>;
}>;
declare const ButtonIcon: ({ Icon, active, variant, }: {
    Icon: (props: {
        color: string;
    }) => ReactElement;
    variant: ButtonProps["variant"];
    active: ButtonProps["active"];
}) => react_jsx_runtime.JSX.Element;

declare const IconButton: react.ForwardRefExoticComponent<ButtonProps & react.RefAttributes<unknown>>;

type LayoutContextType = {
    isDesktop: boolean;
    isMobile: boolean;
};
declare const LayoutProvider: FC<PropsWithChildren>;
declare const useLayout: () => LayoutContextType;

interface Storage {
    getItem: (key: string) => Promise<string | null>;
    setItem: (key: string, value: string) => Promise<void>;
}
declare const StorageProvider: FC<PropsWithChildren<{
    storage: Storage;
}>>;
declare const useStorage: () => Storage;

type HighlightRange = [number, number];
type HighlightRanges = HighlightRange[];
type Refs = State['refs'];
type RefType = Refs[keyof Refs] & {
    allStatuses?: StatusesByStoryIdAndTypeId;
};
type Item = StoriesHash[keyof StoriesHash];
type Dataset = Record<string, Item>;
interface CombinedDataset {
    hash: Refs;
    entries: [string, RefType][];
}
interface ItemRef {
    itemId: string;
    refId: string;
}
interface StoryRef {
    storyId: string;
    refId: string;
}
type Highlight = ItemRef | null;
type Selection = StoryRef | null;
declare function isExpandType(x: any): x is ExpandType;
interface ExpandType {
    showAll: () => void;
    totalCount: number;
    moreCount: number;
}
type SearchItem = Item & {
    refId: string;
    path: string[];
    status?: StatusValue;
    showAll?: () => void;
};
interface SearchResult {
    item: SearchItem;
    score: number | null;
    matches: HighlightRanges[];
}
type SearchResultProps = SearchResult & {
    icon: string;
    isHighlighted: boolean;
    onPress: PressableProps['onPress'];
};
type GetSearchItemProps = (args: {
    item: SearchResult;
    index: number;
    key: string;
}) => SearchResultProps;
type SearchChildrenFn = (args: {
    query: string;
    results: SearchResult[];
    isBrowsing: boolean;
    closeMenu: (cb?: () => void) => void;
    getItemProps: GetSearchItemProps;
    highlightedIndex: number | null;
}) => ReactNode;
type SBUI = (props: {
    story?: StoryContext<ReactRenderer, Args>;
    storyHash: API_IndexHash;
    setStory: (storyId: string) => void;
    storage: Storage;
    theme: Theme;
    children: ReactElement;
}) => ReactElement;

type ToStoriesHashOptions = {
    provider: API_Provider<API>;
    docsOptions: DocsOptions;
    filters: State['filters'];
    allStatuses: StatusesByStoryIdAndTypeId;
};
declare const intersect: <T>(a: T[], b: T[]) => T[];
declare const merge: <TObj = any>(a: TObj, ...b: Partial<TObj>[]) => TObj;
declare const noArrayMerge: <TObj = any>(a: TObj, ...b: Partial<TObj>[]) => TObj;
declare const transformStoryIndexToStoriesHash: (input: API_PreparedStoryIndex | StoryIndexV2 | StoryIndexV3, { provider, docsOptions, filters, allStatuses }: ToStoriesHashOptions) => API_IndexHash | any;
declare const transformStoryIndexV2toV3: (index: StoryIndexV2) => StoryIndexV3;
declare const transformStoryIndexV3toV4: (index: StoryIndexV3) => API_PreparedStoryIndex;
declare const transformStoryIndexV4toV5: (index: API_PreparedStoryIndex) => API_PreparedStoryIndex;

declare const createId: (itemId: string, refId?: string) => string;
declare const prevent: (e: SyntheticEvent) => boolean;
declare const get: (id: string, dataset: Dataset) => Item;
declare const getParent: (id: string, dataset: Dataset) => Item;
declare const getParents: (id: string, dataset: Dataset) => Item[];
declare const getAncestorIds: (data: IndexHash, id: string) => string[];
declare const getDescendantIds: (data: IndexHash, id: string, skipLeafs: boolean) => string[];
declare function getPath(item: Item, ref: RefType): string[];
declare const searchItem: (item: Item, ref: RefType) => SearchItem;
declare function cycle<T>(array: T[], index: number, delta: number): number;
declare const getStateType: (isLoading: boolean, isAuthRequired: boolean, isError: boolean, isEmpty: boolean) => "auth" | "error" | "loading" | "empty" | "ready";
declare const isAncestor: (element?: Element, maybeAncestor?: Element) => boolean;
declare const removeNoiseFromName: (storyName: string) => string;
declare const isStoryHoistable: (storyName: string, componentName: string) => boolean;

/**
 * A hook to memoize a style. Uses `ViewStyle` per default, but can be used with other styles deriving from `FlexStyle` as well, such as `TextStyle`.
 * @param styleFactory The function that returns a style
 * @param deps The dependencies to trigger memoization re-evaluation
 * @see ["Memoize!!! ðŸ’¾ - a react (native) performance guide"](https://gist.github.com/mrousavy/0de7486814c655de8a110df5cef74ddc)
 * @example
 *
 * // simple object styles
 * const style1 = useStyle(() => ({ height: someDynamicValue }), [someDynamicValue])
 *
 * // array styles
 * const style2 = useStyle(
 *   () => [styles.container, props.style, { height: someDynamicValue }],
 *   [props.style, someDynamicValue]
 * );
 */
declare const useStyle: <TStyle extends ViewStyle | TextStyle | ImageStyle, TOutput extends StyleProp<TStyle>>(styleFactory: () => TOutput, deps?: DependencyList) => TOutput;

declare function startCase(str: string): string;

type ExpandedState = Record<string, boolean>;
interface ExpandAction {
    ids: string[];
    value: boolean;
}
interface ExpandedProps {
    refId: string;
    data: StoriesHash;
    initialExpanded?: ExpandedState;
    rootIds: string[];
    selectedStoryId: string | null;
    onSelectStoryId: (storyId: string) => void;
}
declare const useExpanded: ({ refId, data, initialExpanded, rootIds, selectedStoryId, }: ExpandedProps) => [ExpandedState, Dispatch<ExpandAction>];

declare const useLastViewed: (selection: Selection) => {
    getLastViewed: () => any[];
    clearLastViewed: () => void;
};

declare const useStoreBooleanState: (key: string, defaultValue: boolean) => ReturnType<typeof useState<boolean>>;
declare const useStoreNumberState: (key: string, defaultValue: number) => [number, (value: number | ((prev: number) => number)) => void];

export { Button, ButtonIcon, type ButtonProps, ButtonText, type CombinedDataset, type Dataset, type ExpandAction, type ExpandType, type ExpandedProps, type ExpandedState, type GetSearchItemProps, type Highlight, type HighlightRange, type HighlightRanges, IconButton, type Item, type ItemRef, LayoutProvider, type RefType, type Refs, type SBUI, type SearchChildrenFn, type SearchItem, type SearchResult, type SearchResultProps, type Selection, type Storage, StorageProvider, type StoryRef, createId, cycle, get, getAncestorIds, getDescendantIds, getParent, getParents, getPath, getStateType, intersect, isAncestor, isExpandType, isStoryHoistable, merge, noArrayMerge, prevent, removeNoiseFromName, searchItem, startCase, transformStoryIndexToStoriesHash, transformStoryIndexV2toV3, transformStoryIndexV3toV4, transformStoryIndexV4toV5, useExpanded, useLastViewed, useLayout, useStorage, useStoreBooleanState, useStoreNumberState, useStyle };
